<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Carte Intervenantes / Bénéficiaires</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet"
    href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html,body,#map{height:100%;margin:0}
    .panel{position:absolute;top:10px;left:10px;z-index:1000;background:#fff;padding:10px;border-radius:8px;max-width:360px;box-shadow:0 2px 12px rgba(0,0,0,.15);font:14px system-ui}
    .btn{padding:6px 10px;border:1px solid #ccc;border-radius:6px;background:#f7f7f7;cursor:pointer}
    .btn + .btn { margin-left:6px }
    .row{margin:6px 0}
    .muted{color:#666}
  </style>
</head>
<body>
<div class="panel">
  <div class="row"><strong>Filtres intervenantes</strong><div id="filters"></div></div>

  <div class="row">
    <button class="btn" id="btnSecteurs" title="Afficher les secteurs concaves">Secteurs concaves</button>
    <button class="btn" id="btnIso10" title="Isochrones 10 min">Isochrone 10 min</button>
    <button class="btn" id="btnIso15" title="Isochrones 15 min">Isochrone 15 min</button>
  </div>

  <div class="row">
    <input type="email" id="email" placeholder="you@mairie.fr" style="width:58%" />
    <button class="btn" id="btnLogin">Connexion</button>
    <button class="btn" id="btnLogout" style="display:none">Déconnexion</button>
    <div class="muted" id="authState" style="margin-top:6px">Non connecté</div>
  </div>

  <div class="row"><em>Conseil : Maj+clic sur un bénéficiaire pour éditer (si autorisé).</em></div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>

<script>
/*** CONFIG ***/
const SUPABASE_URL = 'https://fauiwnvaynlbfzqlilbi.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhdWl3bnZheW5sYmZ6cWxpbGJpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1NDM0NzksImV4cCI6MjA3MTExOTQ3OX0.wDBJt9fw44LFOZOoJrva8DXhR9ScsZpZMDdHiWfU1xE';
const MAP_CENTER = [48.8566, 2.3522], MAP_ZOOM = 12;

/** ➜ ALLOWLIST: seuls ces e-mails peuvent ÉDITER */
const ALLOW_EDIT = new Set(['mariemotta.geo@gmail.com','mariemotta@gmail.com']);

const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
let session = null;

/*** MAP ***/
const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(map);

let lyrInterv, lyrBenef, editGroup = L.featureGroup().addTo(map);
const hullLayer = L.layerGroup().addTo(map);
const isoLayer  = L.layerGroup().addTo(map);
const filterSet = new Set();

/*** HELPERS ***/
function colorFor(id){ let h=0; for (let i=0;i<String(id).length;i++) h=(h*31+String(id).charCodeAt(i))%360; return `hsl(${h},70%,45%)`; }
function canView(){ return !!session; } // ➜ VOIR = connecté
function canEdit(){
  const email = session?.user?.email?.toLowerCase() || '';
  return !!session && ALLOW_EDIT.has(email); // ➜ ÉDITER = allowlist
}
function status(s){ document.getElementById('authState').textContent = s; }

function clearLayers(){
  if (lyrBenef) { map.removeLayer(lyrBenef); lyrBenef = null; }
  if (lyrInterv){ map.removeLayer(lyrInterv); lyrInterv = null; }
  hullLayer.clearLayers();
  isoLayer.clearLayers();
  editGroup.clearLayers();
}

/** Afficher/masquer les contrôles d'édition et brancher Leaflet.draw uniquement si autorisé */
function refreshEditingUI(){
  // Afficher ou masquer certains boutons si nécessaire (ex: actions sensibles d'édition)
  // Ici, Secteurs/Isochrones peuvent rester visibles en lecture; on bloque l'action plus bas si non connecté.
  // Contrôle Leaflet Draw (déplacement des points) ➜ seulement pour éditeurs
  if (window.drawCtrl) { map.removeControl(window.drawCtrl); window.drawCtrl = null; }
  if (canEdit()) {
    window.drawCtrl = new L.Control.Draw({ draw:false, edit:{ featureGroup: editGroup, remove:false } });
    map.addControl(window.drawCtrl);
    map.off(L.Draw.Event.EDITED);
    map.on(L.Draw.Event.EDITED, async (e)=>{
      const layers = e.layers;
      for (const id in layers._layers){
        const layer = layers._layers[id];
        const f = layer.feature, ll = layer.getLatLng();
        // RLS bloquera si l'utilisateur n'est pas autorisé, mais on ne devrait jamais arriver ici sans canEdit()
        const { error } = await supabase.from('beneficiaires')
          .update({ lat: ll.lat, lon: ll.lng })
          .eq('id_beneficiaire', f.properties.id_beneficiaire);
        if (error) alert(error.message);
      }
      await loadData();
    });
  } else {
    map.off(L.Draw.Event.EDITED);
  }
}

/*** DATA LOADING — appelé UNIQUEMENT une fois connecté ***/
async function loadData(){
  // Lecture protégée : RLS côté DB exige auth ; côté front on ne vient ici que si canView()
  const [resI, resB] = await Promise.all([
    supabase.from('vw_intervenantes_points').select('*'),
    supabase.from('vw_beneficiaires_enriched').select('*')
  ]);
  if (resI.error || resB.error) {
    console.error(resI.error || resB.error);
    return;
  }
  renderInterv(resI.data||[]);
  renderBenef(resB.data||[]);
  buildFilters(resI.data||[], resB.data||[]);
  refreshEditingUI();
}

function renderInterv(rows){
  if (lyrInterv) map.removeLayer(lyrInterv);
  const feats = rows.filter(r=>r.lat && r.lon).map(r=>({
    type:'Feature',
    geometry:{type:'Point', coordinates:[r.lon, r.lat]},
    properties:r
  }));
  lyrInterv = L.geoJSON({type:'FeatureCollection', features:feats},{
    pointToLayer:(f, latlng)=>L.circleMarker(latlng, {radius:7, color:'#000', weight:1, fillColor:colorFor(f.properties.id_intervenante), fillOpacity:.9}),
    onEachFeature:(f,l)=>l.bindTooltip(`${f.properties.id_intervenante} — ${f.properties.nom||''}`)
  }).addTo(map);
}

function renderBenef(rows){
  if (lyrBenef) { map.removeLayer(lyrBenef); editGroup.clearLayers(); }

  function matchesFilter(f){
    if (!filterSet.size) return true;
    const ints = f.properties.intervenantes||[];
    return ints.some(x=>filterSet.has(String(x)));
  }
  const feats = rows.filter(r=>r.lat && r.lon).map(r=>({
    type:'Feature',
    geometry:{type:'Point', coordinates:[r.lon, r.lat]},
    properties:r
  }));
  lyrBenef = L.geoJSON({type:'FeatureCollection', features:feats},{
    pointToLayer:(f, latlng)=>{
      const pid = f.properties.primary_intervenante;
      return L.circleMarker(latlng, {radius:6, color:'#000', weight:1, fillColor: pid?colorFor(pid):'#666', fillOpacity:.8});
    },
    filter: matchesFilter,
    onEachFeature:(f, layer)=>{
      layer.on('click', ()=>{
        const p=f.properties, ints=(p.intervenantes||[]).join(', ');
        const disabled = canEdit() ? '' : 'disabled';
        const html = `
          <b>${p.nom||p.id_beneficiaire}</b><br>
          Adresse: <input id="f_addr" value="${p.adresse_beneficiaire||''}" style="width:100%"><br>
          Intervenantes (CSV): <input id="f_ints" value="${ints}" style="width:100%"><br>
          <button id="btnSave" ${disabled}>Enregistrer</button>
          <button id="btnPrim" ${disabled}>Définir principale</button>
        `;
        layer.bindPopup(html).openPopup();
        layer.once('popupopen', ()=>{
          const $ = id => document.getElementById(id);
          if (canEdit()){
            $('btnSave').onclick = async ()=>{
              const addr = $('f_addr').value.trim();
              const ids  = $('f_ints').value.split(',').map(s=>s.trim()).filter(Boolean);
              // reset liens
              await supabase.from('lien').delete().eq('id_beneficiaire', p.id_beneficiaire);
              if (ids.length){
                const rows = ids.map((id,i)=>({ id_beneficiaire:p.id_beneficiaire, id_intervenante:id, is_primary:i===0 }));
                const { error } = await supabase.from('lien').insert(rows);
                if (error) return alert(error.message);
              }
              const { error: e2 } = await supabase.from('beneficiaires').update({ adresse_beneficiaire: addr }).eq('id_beneficiaire', p.id_beneficiaire);
              if (e2) alert(e2.message);
              await loadData();
            };
            $('btnPrim').onclick = async ()=>{
              const ids = $('f_ints').value.split(',').map(s=>s.trim()).filter(Boolean);
              if (!ids.length) return;
              await supabase.from('lien').update({ is_primary:false }).eq('id_beneficiaire', p.id_beneficiaire);
              const { error } = await supabase.from('lien').update({ is_primary:true })
                .eq('id_beneficiaire', p.id_beneficiaire).eq('id_intervenante', ids[0]);
              if (error) alert(error.message);
              await loadData();
            };
          }
        });
      });
      // Édition géo (drag) ➜ on ajoute tous les layers au featureGroup; Draw n'est activé que si canEdit()
      editGroup.addLayer(layer);
    }
  }).addTo(map);
}

/** Filtres */
function buildFilters(intervRows, benefRows){
  const ids = new Set();
  intervRows.forEach(r=>ids.add(String(r.id_intervenante)));
  (benefRows||[]).forEach(r=>(r.intervenantes||[]).forEach(x=>ids.add(String(x))));
  const box = document.getElementById('filters'); box.innerHTML='';
  Array.from(ids).sort().forEach(id=>{
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" value="${id}"> ${id}`;
    label.querySelector('input').onchange = e=>{
      if (e.target.checked) filterSet.add(id); else filterSet.delete(id);
      // Re-filtrer sur la couche actuelle
      if (lyrBenef) renderBenef(benefRows||[]);
    };
    box.appendChild(label);
  });
}

/*** SECTEURS CONCAVES ***/
document.getElementById('btnSecteurs').onclick = async ()=>{
  if (!canView()) return alert('Connectez-vous pour afficher les secteurs.');
  hullLayer.clearLayers();
  // Recommandé : utilisez la vue GeoJSON côté DB (vw_secteurs_concaves_geojson)
  const { data, error } = await supabase.from('vw_secteurs_concaves_geojson').select('id_intervenante, geojson');
  if (error) return alert(error.message);
  (data||[]).forEach(r => L.geoJSON(r.geojson, { style:{ color: colorFor(r.id_intervenante), weight:2, fillOpacity:.15 }}).addTo(hullLayer));
};

/*** ISOCHRONES ***/
async function doIso(seconds){
  if (!canView()) return alert('Connectez-vous pour afficher les isochrones.');
  isoLayer.clearLayers();
  const { data: rows, error } = await supabase.from('vw_intervenantes_points').select('id_intervenante');
  if (error) return alert(error.message);
  const ids = (Array.from(filterSet).length? Array.from(filterSet) : (rows||[]).map(r=>r.id_intervenante));
  const { data, error: err2 } = await supabase.functions.invoke('isochrones', { body:{ ids, range:[seconds] }});
  if (err2) return alert(err2.message || 'Erreur isochrones');
  L.geoJSON(data, { style:{ color:'#000', weight:1, fillOpacity:.08 } }).addTo(isoLayer);
}
document.getElementById('btnIso10').onclick = ()=>doIso(600);
document.getElementById('btnIso15').onclick = ()=>doIso(900);

/*** AUTH — Magic link (signup bloqué côté dashboard conseillé) ***/
document.getElementById('btnLogin').onclick = async ()=>{
  const email = (document.getElementById('email').value||'').trim().toLowerCase();
  if (!email) return;
  // (Optionnel) côté front, n’envoyer le mail qu’aux 2 e-mails autorisés
  if (!ALLOW_EDIT.has(email)) {
    // Si tu veux permettre la lecture à d’autres comptes, enlève ce bloc.
    return alert('Accès restreint. Contactez l’admin.');
  }
  const { error } = await supabase.auth.signInWithOtp({
    email,
    options:{ emailRedirectTo: location.href, shouldCreateUser: false } // ➜ exige compte pré-créé
  });
  if (error) alert(error.message);
  else alert("Lien de connexion envoyé. Consultez votre email.");
};

document.getElementById('btnLogout').onclick = async ()=>{
  await supabase.auth.signOut();
};

supabase.auth.onAuthStateChange(async (_evt, s)=>{
  session = s?.user ? s : null;
  document.getElementById('btnLogout').style.display = session ? 'inline-block' : 'none';
  status(session ? `Connecté : ${session.user.email}` : 'Non connecté');

  if (canView()) {
    await loadData();        // ➜ charge les données UNIQUEMENT si connecté
  } else {
    clearLayers();           // ➜ vide la carte si déconnexion
  }
  refreshEditingUI();        // ➜ (dé)branche l’édition suivant les droits
});

/*** BOOTSTRAP — au premier chargement, récupérer la session et appliquer la même logique */
(async ()=>{
  const { data: { session: s } } = await supabase.auth.getSession();
  session = s?.user ? s : null;
  document.getElementById('btnLogout').style.display = session ? 'inline-block' : 'none';
  status(session ? `Connecté : ${session.user.email}` : 'Non connecté');
  if (canView()) await loadData();
  refreshEditingUI();
})();
</script>
</body>
</html>
